'''
@author: george
'''

from cybox.core.object import Object as OB, add_external_class, DomainSpecificObjectProperties
from cybox.objects.file_object import File
from cybox.common.object_properties import CustomProperties ,Property
from cybox.common.measuresource import MeasureSource
from mixbox.idgen import IDGenerator
from maec.utils.nsparser import Namespace



class MalwareInstanceObject(OB):
    '''
    classdocs
    '''


    def __init__(self, typeObject=File(),idref='',namespace='',prefix=''):

        self.properties = File()
        self.idgen = IDGenerator()
        #Define Attributes 
        #Define id or idref
        if idref=='':
            self.setid(namespace=namespace, prefix_=prefix)
        else:
            self.idref =idref
        #define has_changed
        self.has_changed = False
        # Add external class Location as an attribute of Malware Instance
        add_external_class(klass=Location,name='Location')
        # Add external class Domain_Specific_Object_Properties as an attribute of Malware Instance
        add_external_class(klass=Domain_Specific_Object_Properties,name='Domain_Specific_Object_Properties')
        
    def setid(self,namespace='',prefix_='bundle'):
        '''
        The given namespace should be had the form xmlns:prefix="URI"
        '''
        if namespace =='' :
            self.id_= self.idgen.create_id(prefix=prefix_)
        else :
            mixedname =''.join(namespace.split(':')[1:])
            name = mixedname.split('=')[1]
            px=mixedname.split('=')[0]
            ns = Namespace(name=name,prefix=px)
            self.idgen._namespace=ns
            self.id_ = self.idgen.create_id(prefix=prefix_) 
    
    def haschanged(self,changed=False):
        self.has_changed =changed        
        
    def setstate(self,state):
        self.state =state
        
    def setdescription(self,description):
        self.description = str(description)
    
    def setproperties(self,property):
        pass

    def createproperty(self,propid='',idref='',datatype='',appears_random=False,is_obfuscated=False,obf_alg='',is_defanged=False,def_alg='',ref_tran_type='',ref_tran='',obs_enc=''):
        property = Property()
        if idref=='':
            property.id_ = propid
        else:
            property.idref = idref
        property.datatype = datatype
        property.appears_random = appears_random
        property.is_obfuscated = is_obfuscated
        property.obfuscation_algorithm_ref = obf_alg
        property.is_defanged = is_defanged
        property.defanging_algorithm_ref = def_alg
        property.refanging_transform_type=ref_tran_type
        property.refanging_transform = ref_tran
        property.observed_encoding =obs_enc
        return property

    #OK
    def setlocation(self,location,id='',idref=''):
        '''
        Set Location attribute to malware instance
        :param id:Set unique location id if exist
        :param idref: Specifies a reference to a unique ID defined elsewhere.
        :param location: Specifies  a physical location
        :return:
        '''
        self.Location.id = id
        self.Location.idref = idref
        self.Location.Name = location

    def setdomainspecificobjectproperties(self,dsop=None):
        self.Domain_Specific_Object_Properties = dsop


    #OK
    def setrelatedobjects(self,related_obj=None,relationship='',inline=True):
        '''
        Adds a related object, the object is child of cybox.core.Object.
        Relationship attribute takes values only from the set cybox_default_vocabularies:ObjectRelationshipEnum.
        Inline attribute specifies  inheritance with the instance.
        '''
        self.add_related(related=related_obj,relationship=relationship,inline=inline)

    #OK
    def setdefinedeffect(self,effect=''):
        '''
        Defined_Effect attribute takes values only from the set cybox_core:EffectTypeEnum
        '''
        self.__setattr__('Definned_Effect',effect)


    def setdiscoverymethod(self):
        pass

#OK
class Domain_Specific_Object_Properties(DomainSpecificObjectProperties):

    def __init__(self):
        super(DomainSpecificObjectProperties,self).__init__()
#OK
class Location():

    def __init__(self,location,location_id='',location_idref=''):
        '''
        Creates an object that describes  a relevant physical location.
        '''
        self.Name = location
        self.id = location_id
        self.idref = location_idref

class Discovery_Method(MeasureSource):

    def __init__(self,information_source_type='',tool_type='',description ='',contributors=[],start_time ='', end_time='',
                 produced_time='',received_time='',observation_location=Location(),tools=[]):
        super(Discovery_Method,self).__init__()
        #information source type is optional and takes values from the set cybox:InformationSourceTypeEnum which can be extended
        self.information_source_type.value(information_source_type)
        #tool type is optional and takes values from the set cybox:ToolTypeEnum which can be extended
        self.tool_type.value(tool_type)
        #description is optional and enables a generalized but structured description of the cyber observation source.
        self.description
        '''
         self.Description =description
        #contributors is optional and it is a list of contributor objects that allow the description of individual contributors that  involved with that instance
        self.Contributors = contributors
        #time is optional and enables description of various time-related properties
        #start_time is optional and describes the starting time for this construct.
        #end_time is optional and describes the ending time for this construct
        #produced_time is optional and describes the time that this construct was produced
        #received_time is optional and describes the time that this construct was received
        self.Start_Time=start_time
        self.End_Time=end_time
        self.Produced_Time=produced_time
        self.Received_Time=received_time
        self.Time = (self.Start_Time,self.End_Time,self.Produced_Time,self.Received_Time)
        #specifies a relevant physical location for the observation measurement of the associated Observable
        self.Observation_Location = observation_location
        #tools is optional and enables description of the tools utilized for this cyber observation source
        self.Tools =tools
        #
        self.platform =''
        self.system = ''
        self.instance =''
        self.observable_location = ''
        '''
    def addcontributor(self,contibutor):
        self.contributors.append(contibutor)

    def addtool(self,tool):
        self.Tools.append(tool)


#OK
class Contibutor():

    def __init__(self,role='', name='', email='', phone='',organization='', start_date='', end_date=''):
        #describes the role played by this contributor
        self.Role =role
        #contains the name of this contributor.
        self.Name =name
        #contains the email of this contributor
        self.Email =email
        #contains a telephone number of this contributor
        self.Phone =phone
        #contains the organization name of this contributor
        self.Organization =organization
        #contains the start date for this contributor's involvement.
        self.Start_Date =start_date
        #contains the end date for this contributor's involvement
        self.End_Date = end_date
        #contains a description (bounding) of the timing of this contributor's involvement
        self.Date =(self.Start_Date,self.End_Date)

class Tool():

    def __init__(self,Name='',Type='',Description='',References=[],Vendor='',Version='',Service_Pack='',Tool_Specific_Data='',Tool_Hashes=[],Tool_Configuration='',Execution_Environment='',Errors='',Metadata='',Compensation_Model=''):
        #contains the name of the tool leveraged
        self.Name= Name
        #contains the type of the tool leveraged
        self.Type = Type
        #contains general descriptive information for this tool
        self.Description = Description
        #contains references to instances or additional information for this tool
        self.References = References
        #contains information identifying the vendor organization for this tool
        self.Vendor = Vendor
        #contains an appropriate version descriptor of this tool
        self.Version = Version
        #contains an appropriate service pack descriptor for this tool.
        self.Service_Pack = Service_Pack
        #contain tool-specific data
        self.Tool_Specific_Data =Tool_Specific_Data
        #
        self.Tool_Hashes = Tool_Hashes
        self.Tool_Configuration = Tool_Configuration
        self.Execution_Environment = Execution_Environment
        self.Errors =Errors
        self.Metadata =Metadata
        self.Compensation_Model = Compensation_Model

    def addreferences(self,reference):
        self.References.append(reference)

    def addtoolhashes(self,hash_val):
        self.Tool_Hashes.append(hash_val)
#OK
class Hash():
    
    def __init__(self,Type,value): 
        self.value = value
        #attribute captures the type of hash, it takes values from the set cybox:HashNameVocab, which can be extended
        self.Type = Type
#OK
class Simple_Hash(Hash):

    def __init__(self,type,value):
        super(Hash,self).__init__(Type=type,value=value)
        #specifies a single result value of a basic cryptograhic hash function outputting a single hexbinary hash value
        self.Simple_Hash_Value = self.value
#OK
class Fuzzy_Hash(Hash):

    def __init__(self,type,value,hash_structure =HashStructure()):
        super(Hash,self).__init__(Type=type,value=value)
        #specifies a single result value of a cryptograhic fuzzy hash function outputting a single complex string based hash value
        self.Fuzzy_Hash_Value = self.value
        #attribute is optional and enables the characterization of the key internal components of a fuzzy hash calculation with a given block size
        self.Fuzzy_Hash_Structure = hash_structure
#OK
class HashStructure():

    def __init__(self,block_size,block_hash = BlockHash()):
        #attribute is optional and specifies the calculated block size for this fuzzy hash calculation
        self.Block_Size = block_size
        #attribute is optional and enables specification of the elemental components utilized for a fuzzy hash calculation on the hashed object utilizing Block_Size to calculate trigger points.
        self.Block_Hash = block_hash

class BlockHash():

    def __init__(self,block_hash_value='',segments=[]):
        self.Block_Hash_Value=block_hash_value
        #attribute is optional and specifies the number of segments identified and utilized within this fuzzy hash calculation
        self.Segment_Count =len(self.Segments)
        self.Segments =segments


if __name__=='__main__':
    mi = MalwareInstanceObject()



    
    